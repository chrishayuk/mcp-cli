# Spec 6.0: Planner Integration ✅ COMPLETE

> **Tier 6 — Execution Graphs & Plans**
> Shift: conversation → reasoning → tools **becomes** intent → plan → execution → memory → replay

## Overview

Integrate `chuk-ai-planner` into mcp-cli so that users can generate, inspect, persist, and execute structured plans that decompose complex tasks into dependency-aware tool call graphs. Plans make workflows reproducible, shareable, and inspectable — Terraform for agents.

## Motivation

Today mcp-cli's conversation loop reasons from scratch every turn. The model decides which tools to call reactively. This works for simple tasks but fails for complex multi-step workflows:

- **No reproducibility** — same prompt may produce different tool sequences
- **No inspection** — can't review what the agent will do before it does it
- **No resumability** — interrupted workflows start over
- **No parallelism awareness** — independent steps execute sequentially because the model emits them one turn at a time

Plans solve all four problems by making the execution graph explicit, persistent, and executable.

## Architecture

### Component Relationships

```
User
  │
  ├── /plan create "task description"
  │     │
  │     ├── PlanAgent (LLM generates structured JSON plan)
  │     │     └── validates tool names against ToolManager catalog
  │     │
  │     └── UniversalPlan (DSL builds graph in GraphStore)
  │           └── PlanRegistry (persists to ~/.mcp-cli/plans/)
  │
  ├── /plan run <id>
  │     │
  │     └── UniversalExecutor
  │           ├── topological sort (respects step dependencies)
  │           ├── variable resolution (${var} syntax)
  │           └── McpToolBackend (bridges to ToolManager)
  │                 └── ToolManager.execute_tool() → MCP servers
  │
  └── /plan list | show | delete | run --dry-run
```

### The Bridge: McpToolBackend

The critical integration point. chuk-ai-planner defines a `ToolExecutionBackend` protocol:

```python
class ToolExecutionBackend(Protocol):
    async def execute_tool(self, request: ToolExecutionRequest) -> ToolExecutionResult
```

The existing `ToolProcessorBackend` calls `CTP.process()` with fake OpenAI payloads. This works for registered Python functions but not for mcp-cli's MCP server tools, which are accessed via `ToolManager.execute_tool()`.

`McpToolBackend` bridges this gap:

```
ToolExecutionRequest (planner)
    → McpToolBackend.execute_tool()
        → ToolManager.execute_tool(name, args)
            → StreamManager → MCP server
        → ToolExecutionResult (planner)
```

### File Layout

```
src/mcp_cli/planning/
  __init__.py              # Public API
  backends.py              # McpToolBackend — bridges planner to ToolManager
  context.py               # PlanningContext — state container for plan operations
  executor.py              # PlanRunner — orchestrates plan execution with guards
  registry.py              # Thin wrapper around chuk-ai-planner's PlanRegistry

src/mcp_cli/commands/plan/
  __init__.py              # Exports PlanCommand
  plan.py                  # PlanCommand — /plan slash command + CLI
```

## Implementation

### 6.0.1 McpToolBackend (`planning/backends.py`)

Implements `ToolExecutionBackend` protocol using mcp-cli's `ToolManager`:

- Receives `ToolExecutionRequest` from planner
- Resolves tool name (handles namespaced tools like `server__tool`)
- Calls `ToolManager.execute_tool(tool_name, args)`
- Wraps `ToolCallResult` → `ToolExecutionResult`
- Measures execution duration
- Catches exceptions → returns error in `ToolExecutionResult`

### 6.0.2 PlanningContext (`planning/context.py`)

State container holding everything needed for plan operations:

- `graph_store: InMemoryGraphStore` — the plan graph
- `tool_manager: ToolManager` — for tool execution and catalog
- `plan_registry: PlanRegistry` — for persistence at `~/.mcp-cli/plans/`
- `get_tool_catalog() -> list[dict]` — returns available tools for LLM plan generation prompts

### 6.0.3 PlanRunner (`planning/executor.py`)

Orchestrates plan execution with mcp-cli's guard infrastructure:

- Creates `UniversalExecutor` with `McpToolBackend`
- Before each step: checks `ToolStateManager.check_all_guards()`
- After each step: calls `ToolStateManager.record_tool_call()`
- Step error handling: retry, fallback, or pause for user input
- Dry-run mode: walks plan without executing, displays resolved args
- Progress callbacks for terminal/dashboard display

### 6.0.4 PlanCommand (`commands/plan/plan.py`)

Unified command supporting chat, CLI, and interactive modes:

| Subcommand | Description |
|------------|-------------|
| `create "description"` | Generate plan from natural language |
| `list` | List saved plans |
| `show <id>` | Display plan structure |
| `run <id>` | Execute a saved plan |
| `run <id> --dry-run` | Trace without executing |
| `run <id> --var key=val` | Parameterized execution |
| `delete <id>` | Remove from registry |
| `resume <id>` | Continue interrupted plan |

Default action (no subcommand): `list`.

### 6.0.5 PlanAction Enum (`config/enums.py`)

```python
class PlanAction(str, Enum):
    CREATE = "create"
    LIST = "list"
    SHOW = "show"
    RUN = "run"
    DELETE = "delete"
    RESUME = "resume"
```

## Plan Format

Plans are persisted as JSON at `~/.mcp-cli/plans/{plan_id}.json`:

```json
{
  "id": "uuid",
  "title": "Add authentication to REST API",
  "description": "Generated from user request",
  "created_at": "2026-02-25T10:00:00Z",
  "tags": [],
  "variables": {},
  "steps": [
    {
      "id": "uuid",
      "index": "1",
      "title": "Read existing app code",
      "tool_calls": [
        {"id": "uuid", "name": "read_file", "args": {"path": "src/app.py"}}
      ],
      "depends_on": [],
      "result_variable": "app_code"
    },
    {
      "id": "uuid",
      "index": "2",
      "title": "Create auth module",
      "tool_calls": [
        {"id": "uuid", "name": "write_file", "args": {"path": "src/auth.py", "content": "${app_code}"}}
      ],
      "depends_on": ["1"],
      "result_variable": "auth_module"
    }
  ]
}
```

## Execution Checkpointing

After each step completes, persist execution state alongside the plan:

`~/.mcp-cli/plans/{plan_id}_state.json`:

```json
{
  "plan_id": "uuid",
  "status": "running",
  "completed_steps": ["1"],
  "variables": {"app_code": "..."},
  "failed_steps": {},
  "started_at": "2026-02-25T10:00:00Z"
}
```

`/plan resume <id>` loads this state, skips completed steps, and continues.

## Guard Integration

Plan execution respects existing guard infrastructure:

1. **Pre-execution**: `ToolStateManager.check_all_guards(tool_name, args)` — budget, runaway, per-tool limits
2. **Execution**: `McpToolBackend.execute_tool(request)` — actual MCP call
3. **Post-execution**: `ToolStateManager.record_tool_call(tool_name)` — tracking
4. **Value binding**: Result stored as `$vN` (guard system) AND `${variable}` (plan context)

Budget is shared with the conversation — plan execution counts against the same limits.

## Dry-Run Mode

`/plan run <id> --dry-run` or `mcp plan run <id> --simulate`:

- Walks the plan in topological order
- Resolves `${var}` references (using defaults or previous step outputs)
- Displays each step: tool name, resolved arguments, dependencies
- Reports estimated tool call count
- No side effects — safe to run in production

## Terminal Display

Plan display in the terminal:

```
Plan: Add authentication to REST API (4 steps)

  1. Read existing app code           [read_file]
  2. Analyze dependencies             [search_code]    ← after: 1
  3. Create auth module               [write_file]     ← after: 1, 2
  4. Run tests                        [run_command]    ← after: 3

Variables: app_code (step 1), deps (step 2), auth_module (step 3)

Execute? [y/n/edit]
```

## Dependencies

- `chuk-ai-planner>=0.2` added to `pyproject.toml`
- Uses: `UniversalPlan`, `UniversalExecutor`, `PlanAgent`, `GraphPlanAgent`, `PlanRegistry`
- Uses: `InMemoryGraphStore` (persistent store is a future tier)

## Testing

- `tests/planning/test_backends.py` — McpToolBackend with mock ToolManager
- `tests/planning/test_executor.py` — PlanRunner with mock backend
- `tests/planning/test_context.py` — PlanningContext initialization
- `tests/commands/test_plan_command.py` — PlanCommand subcommand dispatch

## Future Work (Not in This Tier)

- Parallel step execution (batch steps with no dependencies)
- DAG visualization (terminal ASCII + MCP App browser panel)
- Re-planning on failure (LLM revises remaining steps)
- Plan parameterization (`--var key=value`)
- Integration with CTP's `GreedyDagScheduler` for deadline-aware scheduling
