# Spec: 5.2 Server Health Monitoring

## Problem

When an MCP server dies or becomes unreachable during a session, tool calls fail silently with generic connection errors. The user has no visibility into server health and no way to recover without restarting the entire session.

## Current State

**Already built (upstream `chuk-tool-processor`):**

| Component | Location | What It Does |
|-----------|----------|-------------|
| `transport.send_ping()` | All transports | Lightweight ping using `tools/list` RPC |
| `stream_manager.health_check()` | StreamManager | Concurrent ping of all servers, returns per-server status dict |
| `transport.is_connected()` | All transports | Fast local state check |
| `transport.get_metrics()` | All transports | Ping latency, consecutive failures, last success timestamp |
| SSE health tracking | SSE transport | Grace period (30s), consecutive failure counter (max 5), last successful ping |
| `_is_connection_error()` | ToolManager | Pattern-matches error strings to detect connection failures |
| Middleware retry | Middleware stack | Exponential backoff retry on transient errors (3 retries, 1-30s) |
| OAuth auto-retry | ToolManager | Detects OAuth errors, refreshes token, retries once |

**Not built:**

| Gap | Impact |
|-----|--------|
| No health-check-on-failure | Connection errors reported but not diagnosed |
| No reconnect | Dead server = permanent failure for that server's tools |
| No health visibility | User can't see which servers are up/down |
| No proactive detection | Degradation only discovered when a tool call fails |

## Design

### 5.2.1 Health-Check-on-Failure

When a tool call fails with a connection error, automatically run a health check on the failing server and include the diagnosis in the error response.

**File:** `src/mcp_cli/tools/manager.py` — `execute_tool()`

After the existing connection error detection (line 831+), add:

```
if self._is_connection_error(error_msg):
    health = await self.stream_manager.health_check()
    server_status = health["transports"].get(server_name, {})

    if server_status.get("status") != "healthy":
        error_msg += f" (server {server_name} is {server_status.get('status', 'unknown')})"
        log.warning(f"Server {server_name} health: {server_status}")
```

No auto-reconnect — just enriched error messages so the user/model knows the server is down.

### 5.2.2 Server Health Command

New `/server health` slash command (or `/health` alias) that exposes `stream_manager.health_check()` results.

**File:** `src/mcp_cli/commands/server_health/` (new)

Output:
```
Server Health
  geocoder         healthy    ping: 12ms
  weather          healthy    ping: 45ms
  celestial        unhealthy  last success: 3m ago, 5 consecutive failures
  time             timeout    ping timed out after 5s
```

Shows: server name, status (healthy/unhealthy/timeout/error), ping latency or failure info.

### 5.2.3 Periodic Background Health Check (Optional)

Configurable background health polling during chat sessions.

**File:** `src/mcp_cli/chat/conversation.py`

- `--health-interval N` CLI flag (default: 0 = disabled)
- When enabled, runs `stream_manager.health_check()` every N seconds via `asyncio.create_task`
- Logs warnings on status transitions (healthy → unhealthy)
- Does NOT interrupt the conversation — background only

### 5.2.4 Server Reconnect Command

Manual reconnect for a specific server.

**File:** `src/mcp_cli/commands/server_health/` (same module)

```
/server reconnect <server-name>
```

Implementation:
1. Close the transport for the named server
2. Re-initialize via StreamManager
3. Re-discover tools for that server
4. Report success/failure

**Constraint:** StreamManager currently has no per-server `reconnect()` method. The initial implementation may need to close and reinit the entire StreamManager, or we add a targeted method upstream. Document this limitation.

## Files Modified

| File | Change |
|------|--------|
| `src/mcp_cli/tools/manager.py` | Health-check-on-failure in `execute_tool()`, public `check_server_health()` method |
| `src/mcp_cli/commands/server_health/` | New `/server health` and `/server reconnect` commands |
| `src/mcp_cli/chat/conversation.py` | Optional background health polling task |
| `src/mcp_cli/main.py` | `--health-interval` CLI option |
| `src/mcp_cli/config/defaults.py` | `DEFAULT_HEALTH_INTERVAL = 0` |

## What We're NOT Doing

- **No connection pooling** — each transport remains a singleton
- **No automatic reconnect** — user-triggered only (via `/server reconnect`)
- **No failover** — if a server is down, its tools are unavailable until reconnected
- **No upstream changes** — works with existing StreamManager API

## Test Plan

- Unit test: `_is_connection_error()` with health check enrichment
- Unit test: `/server health` command formatting
- Unit test: background health task creation/cancellation
- Integration test: health check against live SQLite server (existing fixture)
