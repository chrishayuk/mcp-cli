<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>mcp-cli dashboard</title>
<style>
/* â”€â”€ Reset â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
html, body { height: 100%; overflow: hidden; }

/* â”€â”€ Theme variables (overwritten by JS) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
:root {
  --dash-bg: #1e1e2e;
  --dash-bg-surface: #262637;
  --dash-bg-hover: #2e2e42;
  --dash-fg: #e0e0e0;
  --dash-fg-muted: #888899;
  --dash-accent: #7aa2f7;
  --dash-success: #9ece6a;
  --dash-warning: #e0af68;
  --dash-error: #f7768e;
  --dash-info: #7dcfff;
  --dash-border: #3b3b52;
  --dash-font-mono: 'JetBrains Mono','Fira Code','Cascadia Code',monospace;
  --dash-font-ui: 'Inter',-apple-system,sans-serif;
  --dash-font-size: 13px;
  --dash-radius: 6px;
  --dash-spacing: 8px;
}

body {
  background: var(--dash-bg);
  color: var(--dash-fg);
  font-family: var(--dash-font-ui);
  font-size: var(--dash-font-size);
  display: flex;
  flex-direction: column;
  height: 100vh;
}

/* â”€â”€ Toolbar â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#toolbar {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 0 12px;
  height: 36px;
  min-height: 36px;
  background: var(--dash-bg-surface);
  border-bottom: 1px solid var(--dash-border);
  flex-shrink: 0;
  user-select: none;
}
#toolbar .brand {
  display: flex;
  align-items: center;
  gap: 6px;
  font-weight: 600;
  font-size: 13px;
  color: var(--dash-fg);
}
#conn-dot {
  width: 8px; height: 8px;
  border-radius: 50%;
  background: var(--dash-error);
  flex-shrink: 0;
  transition: background 0.3s;
}
#conn-dot.connected { background: var(--dash-success); }

#toolbar .spacer { flex: 1; }

.tb-btn {
  background: transparent;
  border: 1px solid var(--dash-border);
  color: var(--dash-fg);
  padding: 2px 10px;
  border-radius: var(--dash-radius);
  cursor: pointer;
  font-size: 12px;
  font-family: var(--dash-font-ui);
  white-space: nowrap;
}
.tb-btn:hover { background: var(--dash-bg-hover); }

/* Layout dropdown */
.dropdown { position: relative; }
.dropdown-menu {
  display: none;
  position: absolute;
  top: calc(100% + 4px);
  left: 0;
  background: var(--dash-bg-surface);
  border: 1px solid var(--dash-border);
  border-radius: var(--dash-radius);
  min-width: 140px;
  z-index: 100;
  box-shadow: 0 4px 12px rgba(0,0,0,0.4);
}
.dropdown-menu.open { display: block; }
.dropdown-item {
  padding: 6px 12px;
  cursor: pointer;
  font-size: 12px;
  color: var(--dash-fg);
}
.dropdown-item:hover { background: var(--dash-bg-hover); }
.dropdown-item.active { color: var(--dash-accent); }

/* Toolbar selects (model/provider) */
.tb-select {
  background: var(--dash-bg);
  border: 1px solid var(--dash-border);
  color: var(--dash-fg);
  padding: 2px 6px;
  border-radius: var(--dash-radius);
  font-size: 11px;
  font-family: var(--dash-font-ui);
  cursor: pointer;
  max-width: 140px;
  outline: none;
}
.tb-select:hover { border-color: var(--dash-accent); }
.tb-label {
  font-size: 10px;
  color: var(--dash-fg-muted);
  text-transform: uppercase;
  letter-spacing: .04em;
}
.tb-group {
  display: flex;
  align-items: center;
  gap: 4px;
}

/* Settings panel */
#settings-panel {
  display: none;
  position: fixed;
  top: 40px; right: 8px;
  width: 320px;
  max-height: calc(100vh - 56px);
  overflow-y: auto;
  background: var(--dash-bg-surface);
  border: 1px solid var(--dash-border);
  border-radius: var(--dash-radius);
  z-index: 200;
  padding: 12px;
  box-shadow: 0 4px 16px rgba(0,0,0,0.5);
}
#settings-panel.open { display: block; }
#settings-panel h3 { font-size: 12px; font-weight: 600; margin-bottom: 8px; color: var(--dash-fg-muted); text-transform: uppercase; letter-spacing: .05em; }
#settings-panel label { font-size: 12px; display: block; margin-bottom: 4px; }
#settings-panel select { width: 100%; padding: 4px 6px; background: var(--dash-bg); border: 1px solid var(--dash-border); border-radius: var(--dash-radius); color: var(--dash-fg); font-size: 12px; }
#settings-panel .section { margin-bottom: 12px; padding-bottom: 12px; border-bottom: 1px solid var(--dash-border); }
#settings-panel .section:last-child { border-bottom: none; margin-bottom: 0; padding-bottom: 0; }
#settings-panel textarea {
  width: 100%; padding: 6px 8px; background: var(--dash-bg); border: 1px solid var(--dash-border);
  border-radius: var(--dash-radius); color: var(--dash-fg); font-family: var(--dash-font-mono);
  font-size: 11px; line-height: 1.4; resize: vertical; min-height: 80px; max-height: 300px;
}
#settings-panel textarea:focus { border-color: var(--dash-accent); outline: none; }
#settings-panel .btn-row { display: flex; gap: 6px; margin-top: 6px; }
#settings-panel .btn-sm {
  background: transparent; border: 1px solid var(--dash-border); color: var(--dash-fg);
  padding: 3px 10px; border-radius: var(--dash-radius); cursor: pointer; font-size: 11px;
  font-family: var(--dash-font-ui);
}
#settings-panel .btn-sm:hover { background: var(--dash-bg-hover); }
#settings-panel .btn-sm.primary { background: var(--dash-accent); color: var(--dash-bg); border-color: var(--dash-accent); }
#settings-panel .btn-sm.primary:hover { opacity: 0.9; }
.server-list { list-style: none; padding: 0; margin: 4px 0 0 0; }
.server-item {
  display: flex; align-items: center; gap: 6px; padding: 4px 0;
  font-size: 12px; border-bottom: 1px solid var(--dash-border);
}
.server-item:last-child { border-bottom: none; }
.server-dot { width: 6px; height: 6px; border-radius: 50%; flex-shrink: 0; }
.server-dot.on { background: var(--dash-success); }
.server-dot.off { background: var(--dash-error); }
.server-name { flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
.server-tools { font-size: 10px; color: var(--dash-fg-muted); }

/* â”€â”€ Session drawer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#session-drawer {
  display: none;
  position: fixed;
  top: 40px; left: 8px;
  width: 300px;
  max-height: calc(100vh - 56px);
  overflow-y: auto;
  background: var(--dash-bg-surface);
  border: 1px solid var(--dash-border);
  border-radius: var(--dash-radius);
  z-index: 200;
  padding: 12px;
  box-shadow: 0 4px 16px rgba(0,0,0,0.5);
}
#session-drawer.open { display: block; }
#session-drawer h3 {
  font-size: 12px; font-weight: 600; margin-bottom: 8px;
  color: var(--dash-fg-muted); text-transform: uppercase; letter-spacing: .05em;
  display: flex; align-items: center; justify-content: space-between;
}
.session-list { list-style: none; padding: 0; margin: 0; }
.session-item {
  display: flex; align-items: center; gap: 6px; padding: 8px 6px;
  font-size: 12px; border-bottom: 1px solid var(--dash-border);
  cursor: pointer; border-radius: var(--dash-radius); transition: background 0.15s;
}
.session-item:last-child { border-bottom: none; }
.session-item:hover { background: var(--dash-bg-hover); }
.session-item.active { background: var(--dash-bg-hover); border-left: 2px solid var(--dash-accent); }
.session-info { flex: 1; min-width: 0; }
.session-id { font-family: var(--dash-font-mono); font-size: 11px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
.session-desc { font-size: 10px; color: var(--dash-fg-muted); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
.session-meta { font-size: 10px; color: var(--dash-fg-muted); display: flex; gap: 8px; margin-top: 2px; }
.session-actions { display: flex; gap: 4px; flex-shrink: 0; }
.session-actions button {
  background: transparent; border: none; color: var(--dash-fg-muted);
  cursor: pointer; font-size: 11px; padding: 2px 4px; border-radius: 3px;
}
.session-actions button:hover { color: var(--dash-fg); background: var(--dash-bg-hover); }
.session-actions button.delete:hover { color: var(--dash-error); }
.session-empty { color: var(--dash-fg-muted); font-size: 12px; text-align: center; padding: 16px 0; }

/* â”€â”€ Grid layout â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#grid-wrapper {
  flex: 1;
  position: relative;
  overflow: hidden;
  min-height: 0;
}
#grid-root {
  position: absolute;
  top: 0; left: 0; right: 0; bottom: 0;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}
#view-overlay {
  position: absolute;
  top: 0; left: 0; right: 0; bottom: 0;
  pointer-events: none;
  z-index: 5;
  overflow: hidden;
}
#view-overlay iframe {
  position: absolute;
  pointer-events: auto;
  border: none;
  display: none;
}
.grid-row {
  display: flex;
  flex-direction: row;
  overflow: hidden;
  min-height: 150px;
}
.grid-row + .grid-row { border-top: 1px solid var(--dash-border); }

/* Panel */
.panel {
  display: flex;
  flex-direction: column;
  overflow: hidden;
  min-width: 200px;
  position: relative;
}
.panel + .panel { border-left: 1px solid var(--dash-border); }
.panel.minimized .panel-body { display: none; }
.panel.minimized .panel-header { border-bottom: none; }

/* Panel header */
.panel-header {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 0 8px;
  height: 28px;
  min-height: 28px;
  background: var(--dash-bg-surface);
  border-bottom: 1px solid var(--dash-border);
  flex-shrink: 0;
  cursor: grab;
  user-select: none;
  position: relative; /* for view-picker dropdown */
}
.panel-header:active { cursor: grabbing; }
.panel-icon { font-size: 13px; flex-shrink: 0; }
.panel-view-toggle {
  flex: 1;
  min-width: 0;
  background: transparent;
  border: none;
  color: var(--dash-fg);
  font-size: 12px;
  font-weight: 500;
  font-family: var(--dash-font-ui);
  cursor: pointer;
  text-align: left;
  padding: 0 4px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
.panel-view-toggle:hover { color: var(--dash-accent); }
.panel-view-menu {
  position: absolute;
  top: 28px;
  left: 0;
  min-width: 180px;
  z-index: 50;
}
.panel-btn {
  background: transparent;
  border: none;
  color: var(--dash-fg-muted);
  cursor: pointer;
  padding: 2px 4px;
  border-radius: 3px;
  font-size: 12px;
  line-height: 1;
}
.panel-btn:hover { background: var(--dash-bg-hover); color: var(--dash-fg); }

/* Panel body (empty slot â€” iframes are positioned over it from #view-overlay) */
.panel-body {
  flex: 1;
  overflow: hidden;
  position: relative;
}

/* Panel placeholder */
.panel-placeholder {
  display: flex;
  align-items: center;
  justify-content: center;
  height: 100%;
  color: var(--dash-fg-muted);
  font-size: 12px;
  padding: 16px;
  text-align: center;
}

/* Resize handles */
.resize-handle-col {
  width: 4px;
  cursor: col-resize;
  background: transparent;
  flex-shrink: 0;
  position: relative;
  z-index: 10;
}
.resize-handle-col:hover, .resize-handle-col.dragging { background: var(--dash-accent); }
.resize-handle-row {
  height: 4px;
  cursor: row-resize;
  background: transparent;
  flex-shrink: 0;
  position: relative;
  z-index: 10;
}
.resize-handle-row:hover, .resize-handle-row.dragging { background: var(--dash-accent); }

/* Notification toast */
#toast-container {
  position: fixed;
  bottom: 16px;
  right: 16px;
  z-index: 500;
  display: flex;
  flex-direction: column;
  gap: 8px;
}
.toast {
  background: var(--dash-bg-surface);
  border: 1px solid var(--dash-border);
  border-radius: var(--dash-radius);
  padding: 8px 12px;
  font-size: 12px;
  max-width: 300px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.4);
  animation: slideIn 0.2s ease;
}
.toast.info { border-left: 3px solid var(--dash-info); }
.toast.success { border-left: 3px solid var(--dash-success); }
.toast.warning { border-left: 3px solid var(--dash-warning); }
.toast.error { border-left: 3px solid var(--dash-error); }
@keyframes slideIn { from { opacity:0; transform:translateY(8px); } to { opacity:1; transform:translateY(0); } }

/* Tool approval dialog */
#approval-overlay {
  display: none;
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0,0,0,0.5);
  z-index: 600;
  align-items: center;
  justify-content: center;
}
#approval-overlay.open { display: flex; }
#approval-dialog {
  background: var(--dash-bg-surface);
  border: 1px solid var(--dash-border);
  border-radius: var(--dash-radius);
  padding: 16px;
  max-width: 500px;
  width: 90%;
  box-shadow: 0 4px 24px rgba(0,0,0,0.5);
}
#approval-dialog h3 {
  font-size: 14px;
  color: var(--dash-warning);
  margin-bottom: 8px;
}
#approval-dialog .approval-tool {
  font-family: var(--dash-font-mono);
  font-size: 13px;
  color: var(--dash-accent);
  margin-bottom: 8px;
}
#approval-dialog .approval-args {
  background: var(--dash-bg);
  border: 1px solid var(--dash-border);
  border-radius: var(--dash-radius);
  padding: 8px;
  font-family: var(--dash-font-mono);
  font-size: 11px;
  color: var(--dash-fg-muted);
  max-height: 200px;
  overflow-y: auto;
  white-space: pre-wrap;
  word-break: break-all;
  margin-bottom: 12px;
}
#approval-dialog .approval-btns {
  display: flex;
  gap: 8px;
  justify-content: flex-end;
}
#approval-dialog .approval-btns button {
  padding: 6px 16px;
  border-radius: var(--dash-radius);
  border: 1px solid var(--dash-border);
  cursor: pointer;
  font-size: 12px;
  font-family: var(--dash-font-ui);
}
#approval-dialog .btn-approve {
  background: var(--dash-success);
  color: var(--dash-bg);
  border-color: var(--dash-success);
}
#approval-dialog .btn-deny {
  background: transparent;
  color: var(--dash-error);
  border-color: var(--dash-error);
}
#approval-dialog .btn-approve:hover { opacity: 0.9; }
#approval-dialog .btn-deny:hover { background: var(--dash-bg-hover); }

/* â”€â”€ Responsive: stack panels vertically below 768px â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
@media (max-width: 768px) {
  #toolbar { flex-wrap: wrap; height: auto; min-height: 36px; padding: 4px 8px; gap: 6px; }
  #toolbar .spacer { display: none; }
  #model-group { order: 10; width: 100%; justify-content: center; }
  .grid-row { flex-direction: column; }
  .panel { min-width: unset; min-height: 150px; }
  .panel + .panel { border-left: none; border-top: 1px solid var(--dash-border); }
  .resize-handle-col { display: none; }
  #settings-panel { width: 100%; right: 0; left: 0; top: auto; bottom: 0; max-height: 60vh; border-radius: var(--dash-radius) var(--dash-radius) 0 0; }
  #session-drawer { width: 100%; right: 0; left: 0; top: auto; bottom: 0; max-height: 60vh; border-radius: var(--dash-radius) var(--dash-radius) 0 0; }
  #approval-dialog { max-width: 95%; }
  .toast { max-width: 90vw; }
}

@media (max-width: 480px) {
  #toolbar .brand span:last-child { display: none; }
  .tb-select { max-width: 100px; font-size: 10px; }
  .tb-btn { font-size: 11px; padding: 2px 6px; }
}

/* â”€â”€ Agent tab bar â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#agent-tabs {
  display: none;
  align-items: center;
  gap: 4px;
  padding: 0 12px;
  height: 28px;
  min-height: 28px;
  background: var(--dash-bg);
  border-bottom: 1px solid var(--dash-border);
  flex-shrink: 0;
  user-select: none;
  overflow-x: auto;
}
#agent-tabs.visible { display: flex; }
.agent-tab {
  display: inline-flex;
  align-items: center;
  gap: 5px;
  padding: 3px 10px;
  border: 1px solid transparent;
  border-radius: var(--dash-radius);
  background: transparent;
  color: var(--dash-fg-muted);
  font-size: 11px;
  font-family: var(--dash-font-ui);
  cursor: pointer;
  white-space: nowrap;
  transition: background 0.15s, color 0.15s, border-color 0.15s;
}
.agent-tab:hover { background: var(--dash-bg-hover); color: var(--dash-fg); }
.agent-tab.focused {
  background: var(--dash-bg-surface);
  color: var(--dash-fg);
  border-color: var(--dash-accent);
}
.agent-tab-indicator {
  width: 6px; height: 6px;
  border-radius: 50%;
  flex-shrink: 0;
}
.agent-tab-indicator.active    { background: var(--dash-success); }
.agent-tab-indicator.paused    { background: var(--dash-warning); }
.agent-tab-indicator.completed { background: var(--dash-fg-muted); }
.agent-tab-indicator.failed    { background: var(--dash-error); }

/* (view-stash removed â€” iframes now live permanently in #view-overlay) */
</style>
</head>
<body>

<!-- â”€â”€ Toolbar â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
<div id="toolbar">
  <div class="brand">
    <span id="conn-dot"></span>
    <span>mcp-cli dashboard</span>
  </div>

  <button class="tb-btn" id="new-session-btn" title="New chat session">+</button>
  <button class="tb-btn" id="sessions-btn" title="Session history">Sessions</button>

  <div class="dropdown" id="layout-dropdown">
    <button class="tb-btn" id="layout-btn">Layout â–¾</button>
    <div class="dropdown-menu" id="layout-menu"></div>
  </div>

  <button class="tb-btn" id="add-panel-btn">+ Add Panel</button>
  <div class="dropdown" id="add-panel-dropdown">
    <div class="dropdown-menu" id="add-panel-menu"></div>
  </div>

  <div class="spacer"></div>

  <div class="tb-group" id="model-group" style="display:none">
    <span class="tb-label">Provider</span>
    <select class="tb-select" id="provider-select"></select>
    <span class="tb-label">Model</span>
    <select class="tb-select" id="model-select"></select>
  </div>

  <div class="dropdown" id="export-dropdown">
    <button class="tb-btn" id="export-btn">Export â–¾</button>
    <div class="dropdown-menu" id="export-menu">
      <div class="dropdown-item" data-format="markdown">Export as Markdown</div>
      <div class="dropdown-item" data-format="json">Export as JSON</div>
    </div>
  </div>

  <button class="tb-btn" id="settings-btn">âš™</button>
</div>

<!-- â”€â”€ Agent tab bar (hidden when â‰¤1 agent) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
<div id="agent-tabs"></div>

<!-- â”€â”€ Settings panel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
<div id="settings-panel">
  <div class="section">
    <h3>Theme</h3>
    <select id="theme-select"></select>
  </div>

  <div class="section">
    <h3>System Prompt</h3>
    <textarea id="system-prompt-editor" placeholder="Loading..."></textarea>
    <div class="btn-row">
      <button class="btn-sm primary" id="apply-prompt-btn">Apply</button>
      <button class="btn-sm" id="reset-prompt-btn">Reset to Default</button>
    </div>
  </div>

  <div class="section">
    <h3>MCP Servers</h3>
    <ul class="server-list" id="server-list">
      <li style="font-size:12px;color:var(--dash-fg-muted)">No servers connected</li>
    </ul>
  </div>

  <div class="section">
    <button class="btn-sm" style="width:100%" id="save-layout-btn">Save Current Layout</button>
  </div>

  <div class="section">
    <h3>Conversation</h3>
    <button class="btn-sm" style="width:100%;color:var(--dash-error);border-color:var(--dash-error)" id="clear-history-btn">Clear Chat History</button>
  </div>
</div>

<!-- â”€â”€ Session drawer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
<div id="session-drawer">
  <h3>
    <span>Sessions</span>
    <button class="btn-sm" id="refresh-sessions-btn" style="font-size:10px;padding:2px 6px">Refresh</button>
  </h3>
  <ul class="session-list" id="session-list">
    <li class="session-empty">Loading sessions...</li>
  </ul>
</div>

<!-- â”€â”€ Grid wrapper: grid-root for panel layout, view-overlay for iframes â”€â”€ -->
<div id="grid-wrapper">
  <div id="grid-root"></div>
  <div id="view-overlay"></div>
</div>

<!-- â”€â”€ Tool approval dialog â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
<div id="approval-overlay">
  <div id="approval-dialog">
    <h3>Tool Confirmation Required</h3>
    <div class="approval-tool" id="approval-tool-name"></div>
    <div class="approval-args" id="approval-args"></div>
    <div class="approval-btns">
      <button class="btn-deny" id="approval-deny">Deny</button>
      <button class="btn-approve" id="approval-approve">Approve</button>
    </div>
  </div>
</div>

<!-- â”€â”€ Toast container â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
<div id="toast-container"></div>

<script>
'use strict';

// ================================================================
//  Constants
// ================================================================
const PROTOCOL = 'mcp-dashboard';
const VERSION  = 1;
const WS_URL   = `ws://${location.host}/ws`;
const READY_TIMEOUT_MS = 5000;

// ================================================================
//  State
// ================================================================
let ws           = null;
let connected    = false;
let themes       = {};
let activeTheme  = localStorage.getItem('dash-theme') || 'dark';
let viewRegistry = [];
let layoutConfig = null;
let panels       = {};   // panelId â†’ { panelId, el, viewId, rowEl }
let panelCounter = 0;
const viewPool      = new Map(); // viewId â†’ { iframe, ready, accepts, _readyTimeout }
const popoutWindows = new Map(); // viewId â†’ { win, intervalId }

// Multi-agent state
let agentList       = [];        // array of agent descriptors from AGENT_LIST
let focusedAgentId  = null;      // currently focused agent id
const AGENT_COLORS  = ['#7aa2f7','#9ece6a','#e0af68','#f7768e','#7dcfff','#bb9af7','#ff9e64','#73daca'];
const agentColorMap = new Map(); // agent_id â†’ stable color

// ================================================================
//  WebSocket (exponential backoff reconnect)
// ================================================================
let _wsBackoff = 1000;         // current backoff delay (ms)
const _WS_BACKOFF_MAX = 30000; // cap at 30 s
let _wsReconnectTimer = null;

function connectWS() {
  if (_wsReconnectTimer) { clearTimeout(_wsReconnectTimer); _wsReconnectTimer = null; }
  // Close existing connection before creating a new one
  if (ws) { try { ws.onclose = null; ws.close(); } catch(e) {} ws = null; }
  ws = new WebSocket(WS_URL);

  ws.onopen = () => {
    connected = true;
    _wsBackoff = 1000; // reset on success
    document.getElementById('conn-dot').classList.add('connected');
    showToast('success', 'Connected to dashboard server', 2000);
    // Request agent list (router will send AGENT_LIST)
    sendToBridge({ type: 'REQUEST_AGENT_LIST' });
    // Request current config (model, servers, system prompt)
    sendToBridge({ type: 'REQUEST_CONFIG' });
    // Request tool registry
    sendToBridge({ type: 'REQUEST_TOOLS' });
  };

  ws.onclose = () => {
    const wasConnected = connected;
    connected = false;
    document.getElementById('conn-dot').classList.remove('connected');
    if (wasConnected) showToast('warning', `Disconnected â€” reconnecting in ${Math.round(_wsBackoff/1000)}sâ€¦`, _wsBackoff);
    _wsReconnectTimer = setTimeout(() => {
      _wsBackoff = Math.min(_wsBackoff * 2, _WS_BACKOFF_MAX);
      connectWS();
    }, _wsBackoff);
  };

  ws.onerror = () => {
    ws.close();
  };

  ws.onmessage = (evt) => {
    let msg;
    try { msg = JSON.parse(evt.data); } catch { return; }
    handleBridgeMessage(msg);
  };
}

function sendToBridge(msg) {
  if (ws && ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify(msg));
  }
}

// ================================================================
//  Multi-agent helpers
// ================================================================
function agentColor(agentId) {
  if (!agentColorMap.has(agentId)) {
    agentColorMap.set(agentId, AGENT_COLORS[agentColorMap.size % AGENT_COLORS.length]);
  }
  return agentColorMap.get(agentId);
}

function renderAgentTabs() {
  const bar = document.getElementById('agent-tabs');
  bar.innerHTML = '';
  if (agentList.length <= 1) { bar.classList.remove('visible'); return; }
  bar.classList.add('visible');
  for (const agent of agentList) {
    const btn = document.createElement('button');
    btn.className = 'agent-tab' + (agent.agent_id === focusedAgentId ? ' focused' : '');
    const dot = document.createElement('span');
    dot.className = 'agent-tab-indicator ' + (agent.status || 'active');
    btn.appendChild(dot);
    const label = document.createElement('span');
    label.textContent = agent.name || agent.agent_id;
    btn.appendChild(label);
    btn.addEventListener('click', () => focusAgent(agent.agent_id));
    bar.appendChild(btn);
  }
}

function focusAgent(agentId) {
  if (agentId === focusedAgentId) return;
  focusedAgentId = agentId;
  renderAgentTabs();
  sendToBridge({ type: 'FOCUS_AGENT', agent_id: agentId });
  // Update subscription to include focused agent + global
  sendToBridge({ type: 'SUBSCRIBE', agents: [agentId], global: true });
}

function handleAgentList(payload) {
  agentList = payload.agents || [];
  if (!focusedAgentId && agentList.length > 0) {
    focusedAgentId = agentList[0].agent_id;
  }
  renderAgentTabs();
}

function handleAgentRegistered(payload) {
  const existing = agentList.find(a => a.agent_id === payload.agent_id);
  if (!existing) agentList.push(payload);
  if (!focusedAgentId && agentList.length > 0) {
    focusedAgentId = agentList[0].agent_id;
  }
  renderAgentTabs();
}

function handleAgentUnregistered(payload) {
  agentList = agentList.filter(a => a.agent_id !== payload.agent_id);
  if (focusedAgentId === payload.agent_id) {
    focusedAgentId = agentList.length > 0 ? agentList[0].agent_id : null;
  }
  renderAgentTabs();
}

function handleAgentStatus(payload) {
  const agent = agentList.find(a => a.agent_id === payload.agent_id);
  if (agent) agent.status = payload.status;
  renderAgentTabs();
}

function isMultiAgent() { return agentList.length > 1; }
function isFocusedAgent(msg) {
  if (!isMultiAgent()) return true;
  const aid = (msg.payload && msg.payload.agent_id) || msg.agent_id;
  return !aid || aid === focusedAgentId;
}

// ================================================================
//  Bridge message routing
// ================================================================
// Cached payloads for replaying to late-loading views
let _cachedToolRegistry = null;
let _cachedPlanUpdate = null;

function handleBridgeMessage(msg) {
  switch (msg.type) {
    case 'VIEW_REGISTRY':
      // Merge dynamic views from bridge without clobbering builtins
      // Envelope format: msg.payload.views; legacy format: msg.views
      mergeViewRegistry((msg.payload && msg.payload.views) || msg.views || []);
      rebuildAddPanelMenu();
      break;

    // â”€â”€ Agent lifecycle messages â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    case 'AGENT_LIST':
      handleAgentList(msg.payload);
      broadcastToViewType('agents', 'AGENT_LIST', msg.payload);
      break;

    case 'AGENT_REGISTERED':
      handleAgentRegistered(msg.payload);
      broadcastToViewType('agents', 'AGENT_REGISTERED', msg.payload);
      break;

    case 'AGENT_UNREGISTERED':
      handleAgentUnregistered(msg.payload);
      broadcastToViewType('agents', 'AGENT_UNREGISTERED', msg.payload);
      break;

    case 'AGENT_STATUS':
      handleAgentStatus(msg.payload);
      broadcastToViewType('agents', 'AGENT_STATUS', msg.payload);
      break;

    // â”€â”€ Agent-scoped messages â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    case 'TOOL_RESULT':
      sendToActivityStream('TOOL_RESULT', msg.payload);
      if (isFocusedAgent(msg)) routeToViews('TOOL_RESULT', msg.payload);
      break;

    case 'AGENT_STATE':
      if (isFocusedAgent(msg)) broadcastToViews('AGENT_STATE', msg.payload);
      broadcastToViewType('agents', 'AGENT_STATE', msg.payload);
      break;

    case 'CONVERSATION_MESSAGE':
      sendToActivityStream('CONVERSATION_MESSAGE', msg.payload);
      if (isFocusedAgent(msg)) broadcastToViewType('conversation', 'CONVERSATION_MESSAGE', msg.payload);
      break;

    case 'CONVERSATION_TOKEN':
      if (isFocusedAgent(msg)) broadcastToViewType('conversation', 'CONVERSATION_TOKEN', msg.payload);
      break;

    case 'CONVERSATION_HISTORY':
      if (isFocusedAgent(msg)) broadcastToViewType('conversation', 'CONVERSATION_HISTORY', msg.payload);
      break;

    case 'ACTIVITY_HISTORY':
      sendToActivityStream('ACTIVITY_HISTORY', msg.payload);
      break;

    case 'CONFIG_STATE':
      handleConfigState(msg.payload);
      broadcastToViews('CONFIG_STATE', msg.payload);
      break;

    case 'TOOL_REGISTRY':
      _cachedToolRegistry = msg.payload;
      broadcastToViewType('tools', 'TOOL_REGISTRY', msg.payload);
      break;

    case 'TOOL_APPROVAL_REQUEST':
      handleToolApprovalRequest(msg.payload);
      break;

    case 'PLAN_UPDATE':
      _cachedPlanUpdate = msg.payload;
      broadcastToViewType('plan', 'PLAN_UPDATE', msg.payload);
      sendToActivityStream('PLAN_UPDATE', msg.payload);
      break;

    case 'SESSION_STATE':
      handleSessionState(msg.payload);
      break;

    case 'SESSION_LIST':
      handleSessionList(msg.payload);
      break;

    case 'THEME':
      applyTheme(msg.payload);
      break;

    default:
      break;
  }
}

// ================================================================
//  View Pool â€” iframes persist across layout changes
// ================================================================
function mergeViewRegistry(dynamicViews) {
  // Keep builtins, add/update dynamic views
  const builtinIds = new Set(viewRegistry.filter(v => v.source === 'builtin').map(v => v.id));
  const merged = viewRegistry.filter(v => v.source === 'builtin');
  for (const v of dynamicViews) {
    if (!builtinIds.has(v.id)) merged.push(v);
  }
  viewRegistry = merged;
}

function srcForView(viewId) {
  const vInfo = viewRegistry.find(v => v.id === viewId);
  if (vInfo && vInfo.url) return vInfo.url;
  if (viewId === 'builtin:agent-terminal') return '/views/agent-terminal.html';
  if (viewId === 'builtin:activity-stream') return '/views/activity-stream.html';
  if (viewId === 'builtin:tool-browser')    return '/views/tool-browser.html';
  if (viewId === 'builtin:plan-viewer')     return '/views/plan-viewer.html';
  return '';
}

function getOrCreateView(viewId) {
  if (viewPool.has(viewId)) return viewPool.get(viewId);
  const view = { iframe: null, ready: false, accepts: [], _readyTimeout: null };
  const iframe = document.createElement('iframe');
  iframe.sandbox = 'allow-scripts allow-same-origin allow-forms';
  iframe.allow = '';
  iframe.src = srcForView(viewId);
  iframe.dataset.viewId = viewId;
  view.iframe = iframe;
  viewPool.set(viewId, view);
  // Append to view-overlay â€” iframes NEVER move between parents (reparenting
  // destroys browsing context in all modern browsers).  They stay here
  // permanently and are positioned over panel body slots via syncViewPositions().
  document.getElementById('view-overlay').appendChild(iframe);
  return view;
}

function attachViewToSlot(viewId) {
  if (!viewId) return;
  const view = getOrCreateView(viewId);
  // No reparenting â€” iframe stays in #view-overlay.
  // syncViewPositions() will position it over the panel body.
  requestAnimationFrame(() => syncViewPositions());
  // Start ready timeout only for first load
  if (!view.ready && !view._readyTimeout) {
    view._readyTimeout = setTimeout(() => {
      if (!view.ready) {
        const p = findPanelHostingView(viewId);
        const body = p?.el.querySelector('.panel-body');
        if (body) showPanelError(body, 'View did not respond in time.');
      }
    }, READY_TIMEOUT_MS);
  }
}

function findViewIdByWindow(win) {
  for (const [viewId, view] of viewPool) {
    if (view.iframe && view.iframe.contentWindow === win) return viewId;
  }
  return null;
}

function findPanelHostingView(viewId) {
  for (const panel of Object.values(panels)) {
    if (panel.viewId === viewId) return panel;
  }
  return null;
}

function sendInitToView(viewId, panel) {
  const view = viewPool.get(viewId);
  if (!view || !view.iframe) return;
  const themeObj = themes[activeTheme] || themes['dark'] || {};
  const bodyEl = panel.el.querySelector('.panel-body');
  const dims = bodyEl
    ? { width: bodyEl.clientWidth, height: bodyEl.clientHeight }
    : { width: 800, height: 450 };
  postToIframe(view.iframe, 'INIT', {
    view_id: viewId,
    panel_id: panel.panelId,
    agent_id: focusedAgentId,
    theme: themeToCSS(themeObj),
    dimensions: dims,
  });
}

function updatePanelHeader(panel) {
  const iconEl = panel.el.querySelector('.panel-icon');
  const nameEl = panel.el.querySelector('.panel-view-toggle');
  if (iconEl) iconEl.textContent = iconForView(panel.viewId);
  if (nameEl) nameEl.textContent = labelForView(panel.viewId) + ' â–¾';
}

function switchPanelView(panelId, newViewId) {
  const panel = panels[panelId];
  if (!panel || panel.viewId === newViewId) return;
  // Just update the mapping â€” no iframe DOM manipulation needed.
  // The old view's iframe hides automatically via syncViewPositions()
  // (it will no longer be hosted by any panel).
  panel.viewId = newViewId;
  getOrCreateView(newViewId); // ensure iframe exists
  updatePanelHeader(panel);
  requestAnimationFrame(() => syncViewPositions());
  // If already ready, send INIT with current dimensions
  const view = viewPool.get(newViewId);
  if (view?.ready) sendInitToView(newViewId, panel);
}

// ================================================================
//  Message routing
// ================================================================
function routeToViews(type, payload) {
  const serverName = payload.server_name;
  const metaView   = payload.meta_ui?.view;
  for (const panel of Object.values(panels)) {
    const view = viewPool.get(panel.viewId);
    if (!view?.ready || !view.iframe) continue;
    const vid = panel.viewId;
    if (vid === 'builtin:activity-stream') { postToIframe(view.iframe, type, payload); continue; }
    if (metaView && vid === metaView)       { postToIframe(view.iframe, type, payload); continue; }
    const vInfo = viewRegistry.find(v => v.id === vid);
    if (vInfo && vInfo.source === serverName) postToIframe(view.iframe, type, payload);
  }
  for (const [viewId, entry] of popoutWindows) {
    if (entry.win.closed) continue;
    if (viewId === 'builtin:activity-stream' ||
        (metaView && viewId === metaView) ||
        viewRegistry.find(v => v.id === viewId && v.source === serverName)) {
      postToPopout(entry.win, type, payload);
    }
  }
}

function broadcastToViews(type, payload) {
  for (const panel of Object.values(panels)) {
    const view = viewPool.get(panel.viewId);
    if (view?.ready && view.iframe) postToIframe(view.iframe, type, payload);
  }
  for (const [, entry] of popoutWindows) {
    if (!entry.win.closed) postToPopout(entry.win, type, payload);
  }
}

function sendToActivityStream(type, payload) {
  // Send a message specifically to the activity stream view (embedded or popout)
  for (const panel of Object.values(panels)) {
    if (panel.viewId !== 'builtin:activity-stream') continue;
    const view = viewPool.get(panel.viewId);
    if (view?.ready && view.iframe) postToIframe(view.iframe, type, payload);
  }
  for (const [viewId, entry] of popoutWindows) {
    if (viewId === 'builtin:activity-stream' && !entry.win.closed) {
      postToPopout(entry.win, type, payload);
    }
  }
}

function broadcastToViewType(viewType, type, payload) {
  for (const panel of Object.values(panels)) {
    const view = viewPool.get(panel.viewId);
    if (!view?.ready || !view.iframe) continue;
    const vInfo = viewRegistry.find(v => v.id === panel.viewId);
    if (vInfo && vInfo.type === viewType) {
      postToIframe(view.iframe, type, payload);
    } else if (!vInfo && panel.viewId === 'builtin:agent-terminal' && viewType === 'conversation') {
      // Fallback before viewRegistry is populated
      postToIframe(view.iframe, type, payload);
    }
  }
  for (const [viewId, entry] of popoutWindows) {
    if (entry.win.closed) continue;
    const vInfo = viewRegistry.find(v => v.id === viewId);
    const matches = (vInfo && vInfo.type === viewType) ||
                    (!vInfo && viewId === 'builtin:agent-terminal' && viewType === 'conversation');
    if (matches) postToPopout(entry.win, type, payload);
  }
}

function postToIframe(iframe, type, payload) {
  try {
    iframe.contentWindow.postMessage({ protocol: PROTOCOL, version: VERSION, type, payload }, '*');
  } catch (e) { /* ignore â€” iframe may not be ready */ }
}

function populateViewMenu(menu, panelId) {
  menu.innerHTML = '';
  const currentViewId = panels[panelId]?.viewId;
  for (const v of viewRegistry) {
    const item = document.createElement('div');
    item.className = 'dropdown-item' + (v.id === currentViewId ? ' active' : '');
    item.textContent = (v.icon ? v.icon + ' ' : '') + v.name;
    item.addEventListener('click', (e) => {
      e.stopPropagation();
      menu.classList.remove('open');
      if (v.id !== currentViewId) switchPanelView(panelId, v.id);
    });
    menu.appendChild(item);
  }
  if (!menu.children.length) {
    const item = document.createElement('div');
    item.className = 'dropdown-item';
    item.style.color = 'var(--dash-fg-muted)';
    item.textContent = 'No views available';
    menu.appendChild(item);
  }
}

// ================================================================
//  View â†’ Shell postMessage handler
// ================================================================
window.addEventListener('message', (evt) => {
  const msg = evt.data;
  if (!msg || msg.protocol !== PROTOCOL) return;
  const viewId = findViewIdByWindow(evt.source);
  const panel  = viewId ? findPanelHostingView(viewId) : null;

  switch (msg.type) {
    case 'READY': {
      if (viewId) {
        handleViewReady(viewId, msg.payload);
      } else {
        const popId = findPopoutViewIdByWindow(evt.source);
        if (popId) handlePopoutReady(popId, msg.payload, evt.source);
      }
      break;
    }
    case 'USER_ACTION':
      sendToBridge({ type: 'USER_ACTION', view_id: viewId, ...msg.payload });
      break;
    case 'REQUEST_TOOL':
      sendToBridge({ type: 'REQUEST_TOOL', view_id: viewId, ...msg.payload });
      break;
    case 'USER_MESSAGE':
      sendToBridge({ type: 'USER_MESSAGE', content: msg.payload.content });
      break;
    case 'USER_COMMAND':
      sendToBridge({ type: 'USER_COMMAND', command: msg.payload.command });
      break;
    case 'NOTIFY':
      showToast(msg.payload.level || 'info', msg.payload.message, msg.payload.duration_ms);
      break;
    default:
      break;
  }
});

function handleViewReady(viewId, payload) {
  const view = viewPool.get(viewId);
  if (!view) return;
  const wasReady = view.ready;
  view.ready = true;
  view.accepts = payload.accepts || [];
  view.agent_scope = payload.agent_scope || null; // "focused" | "all" | specific agent_id
  if (view._readyTimeout) { clearTimeout(view._readyTimeout); view._readyTimeout = null; }
  const panel = findPanelHostingView(viewId);
  if (!panel) return;
  updatePanelHeader(panel);
  if (!wasReady) {
    sendInitToView(viewId, panel);
    // Replay cached state to newly ready views
    replayCachedState(viewId, view);
  } else {
    // View reattached to a slot â€” update its dimensions
    notifyResize(panel.panelId);
  }
}

function replayCachedState(viewId, view) {
  const vInfo = viewRegistry.find(v => v.id === viewId);
  const viewType = vInfo?.type;

  // Replay TOOL_REGISTRY to tools-type views
  if (viewType === 'tools' && _cachedToolRegistry) {
    postToIframe(view.iframe, 'TOOL_REGISTRY', _cachedToolRegistry);
  }
  // Replay PLAN_UPDATE to plan-type views and activity stream
  if (_cachedPlanUpdate && (viewType === 'plan' || viewId === 'builtin:activity-stream')) {
    postToIframe(view.iframe, 'PLAN_UPDATE', _cachedPlanUpdate);
  }
  // Replay CONFIG_STATE to all views
  if (_configState) {
    postToIframe(view.iframe, 'CONFIG_STATE', _configState);
  }
  // Replay CONVERSATION_HISTORY to conversation-type views
  if (viewType === 'conversation') {
    // Request fresh history from bridge
    sendToBridge({ type: 'REQUEST_CONFIG' });
  }
}

// ================================================================
//  Theme management
// ================================================================
async function loadThemes() {
  try {
    const resp = await fetch('/themes/themes.json');
    themes = await resp.json();
  } catch {
    themes = {};
  }
  buildThemeSelect();
  applyTheme(themes[activeTheme] || themes['dark'] || {});
}

function themeToCSS(t) {
  return {
    name: t.name,
    bg: t.bg, bg_surface: t.bg_surface, bg_hover: t.bg_hover,
    fg: t.fg, fg_muted: t.fg_muted,
    accent: t.accent, success: t.success, warning: t.warning,
    error: t.error, info: t.info, border: t.border,
    font_mono: t.font_mono, font_ui: t.font_ui,
    font_size: t.font_size, radius: t.radius, spacing: t.spacing,
  };
}

function applyTheme(t) {
  if (!t || !t.bg) return;
  activeTheme = t.name || 'dark';
  localStorage.setItem('dash-theme', activeTheme);

  const root = document.documentElement;
  root.style.setProperty('--dash-bg',         t.bg || '');
  root.style.setProperty('--dash-bg-surface',  t.bg_surface || '');
  root.style.setProperty('--dash-bg-hover',    t.bg_hover || '');
  root.style.setProperty('--dash-fg',          t.fg || '');
  root.style.setProperty('--dash-fg-muted',    t.fg_muted || '');
  root.style.setProperty('--dash-accent',      t.accent || '');
  root.style.setProperty('--dash-success',     t.success || '');
  root.style.setProperty('--dash-warning',     t.warning || '');
  root.style.setProperty('--dash-error',       t.error || '');
  root.style.setProperty('--dash-info',        t.info || '');
  root.style.setProperty('--dash-border',      t.border || '');
  root.style.setProperty('--dash-font-mono',   t.font_mono || '');
  root.style.setProperty('--dash-font-ui',     t.font_ui || '');
  root.style.setProperty('--dash-font-size',   t.font_size || '');
  root.style.setProperty('--dash-radius',      t.radius || '');
  root.style.setProperty('--dash-spacing',     t.spacing || '');

  // Update theme select
  const sel = document.getElementById('theme-select');
  if (sel) sel.value = activeTheme;

  // Propagate THEME to all views
  broadcastToViews('THEME', themeToCSS(t));
}

let _themeChangeHandler = null;
function buildThemeSelect() {
  const sel = document.getElementById('theme-select');
  sel.innerHTML = '';
  for (const name of Object.keys(themes)) {
    const opt = document.createElement('option');
    opt.value = name;
    opt.textContent = name.charAt(0).toUpperCase() + name.slice(1);
    sel.appendChild(opt);
  }
  sel.value = activeTheme;
  // Remove previous listener to avoid stacking
  if (_themeChangeHandler) sel.removeEventListener('change', _themeChangeHandler);
  _themeChangeHandler = () => { applyTheme(themes[sel.value] || {}); };
  sel.addEventListener('change', _themeChangeHandler);
}

// ================================================================
//  Layout rendering
// ================================================================
function defaultLayout() {
  return {
    rows: [
      {
        height: '100%',
        columns: [
          { width: '70%', view: 'builtin:agent-terminal' },
          { width: '30%', view: 'builtin:activity-stream' },
        ],
      },
    ],
  };
}

function renderLayout(layout) {
  const root = document.getElementById('grid-root');
  // Iframes stay in #view-overlay â€” we only rebuild the panel grid.
  // No iframe reparenting occurs, so browsing context is preserved.
  root.innerHTML = '';
  panels = {};

  const rows = layout.rows || [];
  rows.forEach((row, ri) => {
    if (ri > 0) root.appendChild(makeRowHandle(root, ri));
    const rowEl = document.createElement('div');
    rowEl.className = 'grid-row';
    rowEl.style.flex = parseFlex(row.height || '100%');
    root.appendChild(rowEl);
    (row.columns || []).forEach((col, ci) => {
      if (ci > 0) rowEl.appendChild(makeColHandle(rowEl, ci));
      const panelEl = createPanelSlot(col.view || 'auto', rowEl);
      panelEl.style.flex = parseFlex(col.width || '100%');
      rowEl.appendChild(panelEl);
    });
  });

  // Position iframes over their panel body slots after browser layout
  requestAnimationFrame(() => syncViewPositions());
}

function parseFlex(pct) {
  const n = parseFloat(pct);
  return isNaN(n) ? '1' : String(n);
}

function createPanelSlot(viewId, rowEl) {
  const panelId = 'panel_' + (++panelCounter);
  const resolvedViewId = resolveAutoView(viewId);

  const panelEl = document.createElement('div');
  panelEl.className = 'panel';
  panelEl.dataset.panelId = panelId;

  // Header
  const header = document.createElement('div');
  header.className = 'panel-header';
  header.draggable = true;
  header.innerHTML = `
    <span class="panel-icon">${iconForView(resolvedViewId)}</span>
    <button class="panel-view-toggle" title="Switch view">${labelForView(resolvedViewId)} â–¾</button>
    <div class="panel-view-menu dropdown-menu"></div>
    <button class="panel-btn" title="Pop out" data-action="popout">â¤¢</button>
    <button class="panel-btn" title="Minimize" data-action="minimize">âˆ’</button>
    <button class="panel-btn" title="Close" data-action="close">Ã—</button>
  `;
  panelEl.appendChild(header);

  const body = document.createElement('div');
  body.className = 'panel-body';
  panelEl.appendChild(body);

  const panel = { panelId, el: panelEl, viewId: resolvedViewId, rowEl };
  panels[panelId] = panel;

  if (resolvedViewId) {
    attachViewToSlot(resolvedViewId);
  } else {
    const ph = document.createElement('div');
    ph.className = 'panel-placeholder';
    ph.textContent = 'Connect an MCP server with views to populate this panel.';
    body.appendChild(ph);
  }

  // Button + view-picker click handler
  header.addEventListener('click', (e) => {
    const btn = e.target.closest('[data-action]');
    if (btn) {
      e.stopPropagation();
      const action = btn.dataset.action;
      if (action === 'minimize') { panelEl.classList.toggle('minimized'); requestAnimationFrame(() => syncViewPositions()); }
      else if (action === 'close') closePanel(panelId);
      else if (action === 'popout') popoutPanel(panel);
      return;
    }
    if (e.target.classList.contains('panel-view-toggle')) {
      e.stopPropagation();
      const menu = header.querySelector('.panel-view-menu');
      if (!menu.classList.contains('open')) populateViewMenu(menu, panelId);
      menu.classList.toggle('open');
    }
  });

  // Drag-to-swap
  header.addEventListener('dragstart', (e) => e.dataTransfer.setData('text/plain', panelId));
  panelEl.addEventListener('dragover', (e) => e.preventDefault());
  panelEl.addEventListener('drop', (e) => {
    e.preventDefault();
    const srcId = e.dataTransfer.getData('text/plain');
    if (srcId && srcId !== panelId) swapPanels(srcId, panelId);
  });

  return panelEl;
}

function resolveAutoView(viewId) {
  if (viewId !== 'auto') return viewId;
  const placed = new Set(Object.values(panels).map(p => p.viewId));
  const builtins = new Set(['builtin:agent-terminal', 'builtin:activity-stream']);
  for (const v of viewRegistry) {
    if (!builtins.has(v.id) && !placed.has(v.id)) return v.id;
  }
  return null;
}

function iconForView(viewId) {
  if (!viewId) return 'â–¡';
  if (viewId === 'builtin:agent-terminal') return 'âŒ¨';
  if (viewId === 'builtin:activity-stream') return 'â—ˆ';
  if (viewId === 'builtin:tool-browser')    return 'ðŸ”§';
  if (viewId === 'builtin:plan-viewer')     return 'ðŸ“‹';
  if (viewId === 'builtin:agent-overview')  return 'ðŸ‘¥';
  const v = viewRegistry.find(v => v.id === viewId);
  return v?.icon || 'â—»';
}

function labelForView(viewId) {
  if (!viewId) return 'Empty';
  if (viewId === 'builtin:agent-terminal') return 'Agent Terminal';
  if (viewId === 'builtin:activity-stream') return 'Activity Stream';
  if (viewId === 'builtin:tool-browser')    return 'Tool Browser';
  if (viewId === 'builtin:plan-viewer')     return 'Plan Viewer';
  if (viewId === 'builtin:agent-overview')  return 'Agent Overview';
  const v = viewRegistry.find(v => v.id === viewId);
  return v ? v.name : viewId;
}

// ================================================================
//  Panel operations
// ================================================================
function closePanel(panelId) {
  const panel = panels[panelId];
  if (!panel) return;
  // Don't touch the iframe â€” it stays alive in #view-overlay.
  // syncViewPositions() will hide it since no panel hosts it.
  const rowEl = panel.rowEl;
  panel.el.remove();
  delete panels[panelId];
  if (rowEl && rowEl.querySelectorAll('.panel').length === 0) rowEl.remove();
  rebuildAddPanelMenu();
  requestAnimationFrame(() => syncViewPositions());
}

function popoutPanel(panel) {
  const url = srcForView(panel.viewId);
  if (!url) return;
  // Reuse existing popup if still open
  const existing = popoutWindows.get(panel.viewId);
  if (existing && !existing.win.closed) { existing.win.focus(); return; }
  const win = window.open(url, `dash-pop-${panel.viewId}`, 'width=900,height=600,menubar=no,toolbar=no,location=no');
  if (!win) return;
  const intervalId = setInterval(() => {
    if (win.closed) { popoutWindows.delete(panel.viewId); clearInterval(intervalId); }
  }, 1000);
  popoutWindows.set(panel.viewId, { win, intervalId });
}

function findPopoutViewIdByWindow(win) {
  for (const [viewId, entry] of popoutWindows) {
    if (entry.win === win) return viewId;
  }
  return null;
}

function handlePopoutReady(viewId, payload, win) {
  const themeObj = themes[activeTheme] || themes['dark'] || {};
  try {
    win.postMessage({
      protocol: PROTOCOL, version: VERSION, type: 'INIT',
      payload: {
        view_id: viewId, panel_id: null, agent_id: focusedAgentId,
        theme: themeToCSS(themeObj),
        dimensions: { width: win.innerWidth || 900, height: win.innerHeight || 600 },
      },
    }, '*');
  } catch (e) { /* ignore */ }
}

function postToPopout(win, type, payload) {
  try { win.postMessage({ protocol: PROTOCOL, version: VERSION, type, payload }, '*'); } catch (e) { /* ignore */ }
}

function swapPanels(aId, bId) {
  const a = panels[aId], b = panels[bId];
  if (!a || !b || a.viewId === b.viewId) return;
  // Just swap the viewId mappings â€” no iframe DOM manipulation.
  // syncViewPositions() repositions iframes over the correct panel bodies.
  const tmp = a.viewId;
  a.viewId = b.viewId;
  b.viewId = tmp;
  updatePanelHeader(a);
  updatePanelHeader(b);
  requestAnimationFrame(() => syncViewPositions());
}

function showPanelError(bodyEl, msg) {
  const ph = document.createElement('div');
  ph.className = 'panel-placeholder';
  ph.style.color = 'var(--dash-error)';
  ph.textContent = msg;
  bodyEl.innerHTML = '';
  bodyEl.appendChild(ph);
}

// ================================================================
//  Resize handles
// ================================================================
function makeColHandle(rowEl, idx) {
  const handle = document.createElement('div');
  handle.className = 'resize-handle-col';
  handle.dataset.handleType = 'col';

  let startX, panels_before, panels_after, startBefore, startAfter;

  handle.addEventListener('mousedown', (e) => {
    e.preventDefault();
    handle.classList.add('dragging');
    startX = e.clientX;

    // Siblings around the handle
    const siblings = Array.from(rowEl.children).filter(c => c.classList.contains('panel'));
    const handleIdx = Array.from(rowEl.children).indexOf(handle);
    const panelsBefore = Array.from(rowEl.children).slice(0, handleIdx).filter(c => c.classList.contains('panel'));
    const panelsAfter  = Array.from(rowEl.children).slice(handleIdx + 1).filter(c => c.classList.contains('panel'));

    panels_before = panelsBefore[panelsBefore.length - 1];
    panels_after  = panelsAfter[0];
    if (!panels_before || !panels_after) return;

    startBefore = panels_before.getBoundingClientRect().width;
    startAfter  = panels_after.getBoundingClientRect().width;

    function onMove(e) {
      const dx = e.clientX - startX;
      const nb = Math.max(200, startBefore + dx);
      const na = Math.max(200, startAfter  - dx);
      panels_before.style.flex = `0 0 ${nb}px`;
      panels_after.style.flex  = `0 0 ${na}px`;
      syncViewPositions();
      notifyResize(panels_before.dataset.panelId);
      notifyResize(panels_after.dataset.panelId);
    }

    function onUp() {
      handle.classList.remove('dragging');
      document.removeEventListener('mousemove', onMove);
      document.removeEventListener('mouseup', onUp);
    }

    document.addEventListener('mousemove', onMove);
    document.addEventListener('mouseup', onUp);
  });

  handle.addEventListener('dblclick', () => {
    // Reset: remove inline flex overrides from all siblings
    Array.from(rowEl.children).filter(c => c.classList.contains('panel')).forEach(p => {
      p.style.flex = '';
    });
    requestAnimationFrame(() => syncViewPositions());
  });

  return handle;
}

function makeRowHandle(root, idx) {
  const handle = document.createElement('div');
  handle.className = 'resize-handle-row';

  let startY, rows, rowBefore, rowAfter, startBefore, startAfter;

  handle.addEventListener('mousedown', (e) => {
    e.preventDefault();
    handle.classList.add('dragging');
    startY = e.clientY;

    rows = Array.from(root.children).filter(c => c.classList.contains('grid-row'));
    const handleIdx = Array.from(root.children).indexOf(handle);
    const rowsBefore = Array.from(root.children).slice(0, handleIdx).filter(c => c.classList.contains('grid-row'));
    const rowsAfter  = Array.from(root.children).slice(handleIdx + 1).filter(c => c.classList.contains('grid-row'));

    rowBefore = rowsBefore[rowsBefore.length - 1];
    rowAfter  = rowsAfter[0];
    if (!rowBefore || !rowAfter) return;

    startBefore = rowBefore.getBoundingClientRect().height;
    startAfter  = rowAfter.getBoundingClientRect().height;

    function onMove(e) {
      const dy = e.clientY - startY;
      const nb = Math.max(150, startBefore + dy);
      const na = Math.max(150, startAfter  - dy);
      rowBefore.style.flex = `0 0 ${nb}px`;
      rowAfter.style.flex  = `0 0 ${na}px`;
      syncViewPositions();
    }

    function onUp() {
      handle.classList.remove('dragging');
      document.removeEventListener('mousemove', onMove);
      document.removeEventListener('mouseup', onUp);
    }

    document.addEventListener('mousemove', onMove);
    document.addEventListener('mouseup', onUp);
  });

  handle.addEventListener('dblclick', () => {
    Array.from(root.children).filter(c => c.classList.contains('grid-row')).forEach(r => {
      r.style.flex = '';
    });
    requestAnimationFrame(() => syncViewPositions());
  });

  return handle;
}

function notifyResize(panelId) {
  const panel = panels[panelId];
  if (!panel?.viewId) return;
  const view = viewPool.get(panel.viewId);
  if (!view?.ready || !view.iframe) return;
  const body = panel.el.querySelector('.panel-body');
  if (!body) return;
  postToIframe(view.iframe, 'RESIZE', { width: body.clientWidth, height: body.clientHeight });
}

// ================================================================
//  View overlay positioning â€” positions iframes over panel body slots
// ================================================================
function syncViewPositions() {
  const overlay = document.getElementById('view-overlay');
  if (!overlay) return;
  const overlayRect = overlay.getBoundingClientRect();

  // Build set of viewIds currently hosted by a visible panel
  const hostedViews = new Set();
  for (const panel of Object.values(panels)) {
    if (panel.viewId) hostedViews.add(panel.viewId);
  }

  for (const [viewId, view] of viewPool) {
    if (!view.iframe) continue;
    const panel = findPanelHostingView(viewId);
    if (panel && !panel.el.classList.contains('minimized')) {
      const body = panel.el.querySelector('.panel-body');
      if (body) {
        const rect = body.getBoundingClientRect();
        if (rect.width > 0 && rect.height > 0) {
          view.iframe.style.display = 'block';
          view.iframe.style.left   = (rect.left   - overlayRect.left) + 'px';
          view.iframe.style.top    = (rect.top    - overlayRect.top)  + 'px';
          view.iframe.style.width  = rect.width  + 'px';
          view.iframe.style.height = rect.height + 'px';
          continue;
        }
      }
    }
    // Not placed, minimized, or zero-size â€” hide
    view.iframe.style.display = 'none';
  }
}

// Re-sync on window resize
window.addEventListener('resize', () => requestAnimationFrame(() => syncViewPositions()));

// ================================================================
//  Layout dropdown
// ================================================================
const BUILTIN_PRESETS = ['Minimal', 'Standard', 'Full'];

function buildLayoutMenu() {
  const menu = document.getElementById('layout-menu');
  menu.innerHTML = '';

  for (const name of BUILTIN_PRESETS) {
    const item = document.createElement('div');
    item.className = 'dropdown-item';
    item.textContent = name;
    item.addEventListener('click', () => {
      applyPreset(name);
      menu.classList.remove('open');
    });
    menu.appendChild(item);
  }
}

function applyPreset(name) {
  const presets = {
    'Minimal': { rows: [{ height: '100%', columns: [{ width: '100%', view: 'builtin:agent-terminal' }] }] },
    'Standard': { rows: [{ height: '100%', columns: [{ width: '70%', view: 'builtin:agent-terminal' }, { width: '30%', view: 'builtin:activity-stream' }] }] },
    'Full': { rows: [{ height: '60%', columns: [{ width: '65%', view: 'builtin:agent-terminal' }, { width: '35%', view: 'builtin:activity-stream' }] }, { height: '40%', columns: [{ width: '50%', view: 'builtin:tool-browser' }, { width: '50%', view: 'builtin:plan-viewer' }] }] },
  };
  const layout = presets[name];
  if (layout) { layoutConfig = layout; renderLayout(layout); }
}

// + Add Panel menu
function rebuildAddPanelMenu() {
  const menu = document.getElementById('add-panel-menu');
  menu.innerHTML = '';
  const placed = new Set(Object.values(panels).map(p => p.viewId));

  for (const v of viewRegistry) {
    if (placed.has(v.id)) continue;
    const item = document.createElement('div');
    item.className = 'dropdown-item';
    item.textContent = v.name;
    item.addEventListener('click', () => {
      addPanelWithView(v.id);
      menu.classList.remove('open');
    });
    menu.appendChild(item);
  }

  if (!menu.children.length) {
    const item = document.createElement('div');
    item.className = 'dropdown-item';
    item.style.color = 'var(--dash-fg-muted)';
    item.textContent = 'No additional views';
    menu.appendChild(item);
  }
}

function addPanelWithView(viewId) {
  const root = document.getElementById('grid-root');
  let lastRow = root.querySelector('.grid-row:last-child');
  if (!lastRow) {
    lastRow = document.createElement('div');
    lastRow.className = 'grid-row';
    lastRow.style.flex = '1';
    root.appendChild(lastRow);
  }
  const existingPanels = lastRow.querySelectorAll('.panel');
  if (existingPanels.length > 0) lastRow.appendChild(makeColHandle(lastRow, existingPanels.length));
  const panelEl = createPanelSlot(viewId, lastRow);
  panelEl.style.flex = '1';
  lastRow.appendChild(panelEl);
  rebuildAddPanelMenu();
  requestAnimationFrame(() => syncViewPositions());
}

// ================================================================
//  Toast notifications
// ================================================================
function showToast(level, message, duration) {
  const container = document.getElementById('toast-container');
  const toast = document.createElement('div');
  toast.className = `toast ${level}`;
  toast.textContent = message;
  container.appendChild(toast);
  setTimeout(() => toast.remove(), duration || 5000);
}

// ================================================================
//  Tool approval dialog
// ================================================================
let _pendingApprovalCallId = null;
let _approvalQueue = [];

function handleToolApprovalRequest(payload) {
  // If another approval is already showing, deny it first (auto-deny stale)
  if (_pendingApprovalCallId) {
    sendToBridge({ type: 'TOOL_APPROVAL_RESPONSE', call_id: _pendingApprovalCallId, approved: false });
  }
  _pendingApprovalCallId = payload.call_id || '';
  document.getElementById('approval-tool-name').textContent = payload.tool_name || 'unknown';
  try {
    document.getElementById('approval-args').textContent =
      JSON.stringify(payload.arguments, null, 2);
  } catch {
    document.getElementById('approval-args').textContent = String(payload.arguments || '{}');
  }
  document.getElementById('approval-overlay').classList.add('open');
  showToast('warning', `Approval needed: ${payload.tool_name}`);
}

document.getElementById('approval-approve').addEventListener('click', () => {
  if (_pendingApprovalCallId) {
    sendToBridge({ type: 'TOOL_APPROVAL_RESPONSE', call_id: _pendingApprovalCallId, approved: true });
  }
  document.getElementById('approval-overlay').classList.remove('open');
  _pendingApprovalCallId = null;
});

document.getElementById('approval-deny').addEventListener('click', () => {
  if (_pendingApprovalCallId) {
    sendToBridge({ type: 'TOOL_APPROVAL_RESPONSE', call_id: _pendingApprovalCallId, approved: false });
  }
  document.getElementById('approval-overlay').classList.remove('open');
  _pendingApprovalCallId = null;
});

// ================================================================
//  Toolbar event wiring
// ================================================================
document.getElementById('layout-btn').addEventListener('click', (e) => {
  e.stopPropagation();
  const menu = document.getElementById('layout-menu');
  menu.classList.toggle('open');
});

document.getElementById('add-panel-btn').addEventListener('click', (e) => {
  e.stopPropagation();
  rebuildAddPanelMenu();
  const menu = document.getElementById('add-panel-menu');
  const btn  = document.getElementById('add-panel-btn');
  const rect = btn.getBoundingClientRect();
  menu.style.left = rect.left + 'px';
  menu.style.top  = (rect.bottom + 4) + 'px';
  menu.style.position = 'fixed';
  menu.classList.toggle('open');
});

document.getElementById('settings-btn').addEventListener('click', (e) => {
  e.stopPropagation();
  document.getElementById('settings-panel').classList.toggle('open');
});

document.getElementById('save-layout-btn').addEventListener('click', () => {
  try {
    localStorage.setItem('dash-layout', JSON.stringify(layoutConfig));
    showToast('success', 'Layout saved');
  } catch (e) {
    showToast('error', 'Could not save layout');
  }
});

document.getElementById('clear-history-btn').addEventListener('click', () => {
  if (!confirm('Clear all chat history and start a new session?')) return;
  sendToBridge({ type: 'CLEAR_HISTORY' });
  showToast('info', 'Chat history cleared');
});

document.getElementById('new-session-btn').addEventListener('click', () => {
  if (!confirm('Save current session and start a new one?')) return;
  sendToBridge({ type: 'NEW_SESSION' });
  showToast('success', 'New session started');
  // Close session drawer if open
  document.getElementById('session-drawer').classList.remove('open');
});

document.getElementById('sessions-btn').addEventListener('click', (e) => {
  e.stopPropagation();
  const drawer = document.getElementById('session-drawer');
  drawer.classList.toggle('open');
  if (drawer.classList.contains('open')) {
    sendToBridge({ type: 'REQUEST_SESSIONS' });
  }
});

document.getElementById('refresh-sessions-btn').addEventListener('click', (e) => {
  e.stopPropagation();
  sendToBridge({ type: 'REQUEST_SESSIONS' });
});

// ================================================================
//  Session list management
// ================================================================
let _sessionList = [];

function handleSessionList(payload) {
  _sessionList = payload.sessions || [];
  const currentId = payload.current_session_id || _currentSessionId;
  renderSessionList(_sessionList, currentId);
}

function renderSessionList(sessions, currentId) {
  const ul = document.getElementById('session-list');
  if (!sessions.length) {
    ul.innerHTML = '<li class="session-empty">No saved sessions</li>';
    return;
  }
  ul.innerHTML = '';
  for (const s of sessions) {
    const li = document.createElement('li');
    li.className = 'session-item' + (s.session_id === currentId ? ' active' : '');

    const info = document.createElement('div');
    info.className = 'session-info';

    const idEl = document.createElement('div');
    idEl.className = 'session-id';
    idEl.textContent = s.description || s.session_id.slice(0, 12);
    info.appendChild(idEl);

    const meta = document.createElement('div');
    meta.className = 'session-meta';
    const msgs = document.createElement('span');
    msgs.textContent = s.message_count + ' msgs';
    meta.appendChild(msgs);
    if (s.model) {
      const model = document.createElement('span');
      model.textContent = s.model;
      meta.appendChild(model);
    }
    const time = document.createElement('span');
    time.textContent = formatSessionTime(s.updated_at);
    meta.appendChild(time);
    info.appendChild(meta);

    li.appendChild(info);

    const actions = document.createElement('div');
    actions.className = 'session-actions';

    if (s.session_id !== currentId) {
      const loadBtn = document.createElement('button');
      loadBtn.textContent = 'Load';
      loadBtn.title = 'Switch to this session';
      loadBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        sendToBridge({ type: 'SWITCH_SESSION', session_id: s.session_id });
        showToast('info', 'Switching session...');
      });
      actions.appendChild(loadBtn);

      const delBtn = document.createElement('button');
      delBtn.textContent = 'Del';
      delBtn.className = 'delete';
      delBtn.title = 'Delete this session';
      delBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        if (confirm('Delete this session permanently?')) {
          sendToBridge({ type: 'DELETE_SESSION', session_id: s.session_id });
        }
      });
      actions.appendChild(delBtn);
    } else {
      const cur = document.createElement('span');
      cur.textContent = 'current';
      cur.style.cssText = 'font-size:10px;color:var(--dash-accent)';
      actions.appendChild(cur);
    }

    li.appendChild(actions);
    ul.appendChild(li);
  }
}

function formatSessionTime(iso) {
  if (!iso) return '';
  try {
    const d = new Date(iso);
    const now = new Date();
    const diff = now - d;
    if (diff < 60000) return 'just now';
    if (diff < 3600000) return Math.floor(diff / 60000) + 'm ago';
    if (diff < 86400000) return Math.floor(diff / 3600000) + 'h ago';
    return d.toLocaleDateString();
  } catch { return ''; }
}

// ================================================================
//  Config state (model, provider, servers, system prompt)
// ================================================================
let _configState = null; // cached CONFIG_STATE payload
let _availableProviders = []; // [{name, models: [...]}]

function handleConfigState(payload) {
  _configState = payload;
  _availableProviders = payload.available_providers || [];
  updateProviderSelect(payload.provider);
  updateModelSelect(payload.provider, payload.model);
  updateServerList(payload.servers || []);
  updateSystemPromptEditor(payload.system_prompt || '');
  // Show model group once we have config
  document.getElementById('model-group').style.display = 'flex';
}

// â”€â”€ Session state â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let _currentSessionId = null;

function handleSessionState(payload) {
  _currentSessionId = payload.session_id || null;
  // Could update a session indicator in toolbar later
}

// â”€â”€ Provider / Model selectors â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function updateProviderSelect(activeProvider) {
  const sel = document.getElementById('provider-select');
  const prev = sel.value;
  sel.innerHTML = '';
  for (const p of _availableProviders) {
    const opt = document.createElement('option');
    opt.value = p.name;
    opt.textContent = p.name;
    sel.appendChild(opt);
  }
  sel.value = activeProvider || prev;
}

function updateModelSelect(provider, activeModel) {
  const sel = document.getElementById('model-select');
  sel.innerHTML = '';
  const pInfo = _availableProviders.find(p => p.name === provider);
  const models = pInfo ? pInfo.models : [];
  if (models.length === 0) {
    const opt = document.createElement('option');
    opt.value = activeModel || '';
    opt.textContent = activeModel || '(unknown)';
    sel.appendChild(opt);
  } else {
    for (const m of models) {
      const opt = document.createElement('option');
      opt.value = m;
      opt.textContent = m;
      sel.appendChild(opt);
    }
  }
  sel.value = activeModel || '';
  // If active model not in list, add it
  if (sel.value !== activeModel && activeModel) {
    const opt = document.createElement('option');
    opt.value = activeModel;
    opt.textContent = activeModel;
    sel.insertBefore(opt, sel.firstChild);
    sel.value = activeModel;
  }
}

document.getElementById('provider-select').addEventListener('change', (e) => {
  const provider = e.target.value;
  const pInfo = _availableProviders.find(p => p.name === provider);
  const models = pInfo ? pInfo.models : [];
  const model = models[0] || '';
  updateModelSelect(provider, model);
  if (model) sendToBridge({ type: 'SWITCH_MODEL', provider, model });
});

document.getElementById('model-select').addEventListener('change', (e) => {
  const model = e.target.value;
  const provider = document.getElementById('provider-select').value;
  if (provider && model) sendToBridge({ type: 'SWITCH_MODEL', provider, model });
});

// â”€â”€ Server list â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function updateServerList(servers) {
  const list = document.getElementById('server-list');
  list.innerHTML = '';
  if (!servers.length) {
    list.innerHTML = '<li style="font-size:12px;color:var(--dash-fg-muted)">No servers connected</li>';
    return;
  }
  for (const s of servers) {
    const li = document.createElement('li');
    li.className = 'server-item';
    li.innerHTML = `
      <span class="server-dot ${s.connected ? 'on' : 'off'}"></span>
      <span class="server-name" title="${esc(s.namespace || s.name)}">${esc(s.name)}</span>
      <span class="server-tools">${esc(String(s.tool_count))} tools</span>
    `;
    list.appendChild(li);
  }
}

function esc(s) {
  return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
}

// â”€â”€ System prompt editor â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function updateSystemPromptEditor(prompt) {
  const editor = document.getElementById('system-prompt-editor');
  // Only update if not focused (avoid overwriting user edits)
  if (document.activeElement !== editor) {
    editor.value = prompt;
  }
}

document.getElementById('apply-prompt-btn').addEventListener('click', () => {
  const text = document.getElementById('system-prompt-editor').value;
  sendToBridge({ type: 'UPDATE_SYSTEM_PROMPT', system_prompt: text });
  showToast('info', 'System prompt updated');
});

document.getElementById('reset-prompt-btn').addEventListener('click', () => {
  sendToBridge({ type: 'UPDATE_SYSTEM_PROMPT', system_prompt: '' });
  showToast('info', 'System prompt reset to default');
});

// ================================================================
//  Export conversation
// ================================================================
document.getElementById('export-btn').addEventListener('click', (e) => {
  e.stopPropagation();
  document.getElementById('export-menu').classList.toggle('open');
});

document.getElementById('export-menu').addEventListener('click', (e) => {
  const item = e.target.closest('[data-format]');
  if (!item) return;
  e.stopPropagation();
  document.getElementById('export-menu').classList.remove('open');
  exportConversation(item.dataset.format);
});

function exportConversation(format) {
  // Collect messages from the agent-terminal iframe
  const msgs = collectConversationMessages();
  if (!msgs.length) { showToast('warning', 'No messages to export'); return; }

  let content, ext, mime;
  if (format === 'json') {
    content = JSON.stringify({ exported: new Date().toISOString(), messages: msgs }, null, 2);
    ext = 'json'; mime = 'application/json';
  } else {
    const lines = [`# Conversation Export\n_${new Date().toISOString()}_\n`];
    for (const m of msgs) {
      const label = m.role === 'user' ? '**You**' : m.role === 'assistant' ? '**Agent**' : `**${m.role}**`;
      lines.push(`### ${label}\n${m.content}\n`);
    }
    content = lines.join('\n');
    ext = 'md'; mime = 'text/markdown';
  }

  const blob = new Blob([content], { type: mime });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `conversation-${Date.now()}.${ext}`;
  a.click();
  URL.revokeObjectURL(url);
  showToast('success', `Exported as ${ext.toUpperCase()}`);
}

function collectConversationMessages() {
  // Find the agent-terminal iframe and read its messages
  for (const [viewId, view] of viewPool) {
    if (viewId !== 'builtin:agent-terminal' || !view.iframe) continue;
    try {
      const doc = view.iframe.contentDocument || view.iframe.contentWindow.document;
      const msgEls = doc.querySelectorAll('.msg');
      const messages = [];
      for (const el of msgEls) {
        const role = el.classList.contains('user') ? 'user' :
                     el.classList.contains('tool-call') ? 'tool' : 'assistant';
        const contentEl = el.querySelector('.msg-content');
        const toolNameEl = el.querySelector('.tool-name');
        let content = '';
        if (contentEl) content = contentEl.textContent || '';
        else if (toolNameEl) content = `[Tool: ${toolNameEl.textContent}]`;
        if (content) messages.push({ role, content });
      }
      return messages;
    } catch (e) {
      // Cross-origin â€” fall back to asking the bridge
      sendToBridge({ type: 'REQUEST_EXPORT' });
      showToast('info', 'Export requested from server');
      return [];
    }
  }
  return [];
}

// Close dropdowns/menus on outside click (but NOT settings panel when clicking inside it)
document.addEventListener('click', (e) => {
  document.getElementById('layout-menu').classList.remove('open');
  document.getElementById('add-panel-menu').classList.remove('open');
  document.getElementById('export-menu').classList.remove('open');
  document.querySelectorAll('.panel-view-menu.open').forEach(m => m.classList.remove('open'));
  // Only close settings panel if click was outside both the panel and the settings button
  const settingsPanel = document.getElementById('settings-panel');
  const settingsBtn   = document.getElementById('settings-btn');
  if (!settingsPanel.contains(e.target) && e.target !== settingsBtn) {
    settingsPanel.classList.remove('open');
  }
  // Only close session drawer if click was outside both the drawer and the sessions button
  const sessionDrawer = document.getElementById('session-drawer');
  const sessionsBtn   = document.getElementById('sessions-btn');
  if (!sessionDrawer.contains(e.target) && e.target !== sessionsBtn) {
    sessionDrawer.classList.remove('open');
  }
});

// ================================================================
//  Initialisation
// ================================================================
async function init() {
  await loadThemes();
  buildLayoutMenu();

  // Bootstrap view registry with builtins
  viewRegistry = [
    { id: 'builtin:agent-terminal', name: 'Agent Terminal', source: 'builtin', icon: 'âŒ¨', type: 'conversation', url: '/views/agent-terminal.html' },
    { id: 'builtin:activity-stream', name: 'Activity Stream', source: 'builtin', icon: 'â—ˆ', type: 'stream', url: '/views/activity-stream.html' },
    { id: 'builtin:tool-browser',    name: 'Tool Browser',    source: 'builtin', icon: 'ðŸ”§', type: 'tools',        url: '/views/tool-browser.html' },
    { id: 'builtin:plan-viewer',     name: 'Plan Viewer',     source: 'builtin', icon: 'ðŸ“‹', type: 'plan',         url: '/views/plan-viewer.html' },
    { id: 'builtin:agent-overview',  name: 'Agent Overview',  source: 'builtin', icon: 'ðŸ‘¥', type: 'agents',       url: '/views/agent-overview.html' },
  ];
  rebuildAddPanelMenu();

  // Render Standard layout by default (guard against corrupted localStorage)
  try {
    const stored = localStorage.getItem('dash-layout');
    layoutConfig = stored ? JSON.parse(stored) : null;
  } catch (e) {
    console.warn('Could not parse stored layout, using default:', e);
    layoutConfig = null;
  }
  layoutConfig = layoutConfig || defaultLayout();
  renderLayout(layoutConfig);

  // Connect WebSocket
  connectWS();
}

init();
</script>
</body>
</html>
